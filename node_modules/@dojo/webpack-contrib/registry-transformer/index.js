"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const path = require("path");
const shared = require('./shared');
const dImportPath = '@dojo/framework/widget-core/d';
const wPragma = 'w';
const fakeComponentName = 'Loadable__';
const outletImportPath = '@dojo/framework/routing/Outlet';
const outletRendererName = 'renderer';
const outletIdName = 'id';
const outletName = 'Outlet';
function createArrowFuncForDefaultImport(modulePath) {
    return ts.createCall(ts.createSignatureDeclaration(ts.SyntaxKind.ImportKeyword), undefined, [
        ts.createLiteral(`${modulePath}`)
    ]);
}
class Visitor {
    constructor(options) {
        this.modulesMap = new Map();
        this.ctorCountMap = new Map();
        this.needsLoadable = false;
        this.all = false;
        this.outlets = [];
        this.registryItems = {};
        this.sync = false;
        this.context = options.context;
        this.contextPath = options.contextPath;
        this.bundlePaths = options.bundlePaths;
        this.basePath = options.basePath;
        this.all = options.all;
        this.outlets = options.outlets;
        this.sync = options.sync;
    }
    visit(node) {
        if (ts.isImportDeclaration(node)) {
            const importPath = node.moduleSpecifier.text;
            if (importPath.match(/^(\.|\.\.)/)) {
                this.setLazyImport(node);
            }
            else if (dImportPath === importPath) {
                this.setWPragma(node);
            }
            else if (outletImportPath === importPath) {
                this.setOutletName(node);
            }
        }
        if (this.isWCall(node)) {
            const text = node.arguments[0].getText();
            if (this.modulesMap.get(text)) {
                node = this.replaceWidgetClassWithString(node);
            }
        }
        if (ts.isJsxElement(node) || ts.isJsxSelfClosingElement(node)) {
            node = this.replaceTSXElementWithLoadable(node);
        }
        return ts.visitEachChild(node, this.visit.bind(this), this.context);
    }
    end(node) {
        let statements = [...node.statements];
        if (Object.keys(this.registryItems).length) {
            const registryItems = Object.keys(this.registryItems).map((label) => {
                const modulePath = this.registryItems[label];
                if (!this.sync) {
                    const importCall = createArrowFuncForDefaultImport(modulePath);
                    return ts.createPropertyAssignment(label, ts.createArrowFunction(undefined, undefined, [], undefined, undefined, importCall));
                }
                return ts.createPropertyAssignment(label, ts.createIdentifier(label));
            });
            const registryStmt = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
                ts.createVariableDeclaration('__autoRegistryItems', undefined, ts.createObjectLiteral(registryItems, false))
            ]));
            let index = 0;
            for (let i = 0; i < statements.length; i++) {
                if (!ts.isImportDeclaration(statements[i])) {
                    index = i;
                    break;
                }
            }
            statements.splice(index, 0, registryStmt);
            if (!this.sync) {
                statements = this.removeImportStatements(statements);
            }
        }
        if (this.needsLoadable) {
            const obj = ts.createObjectLiteral([
                ts.createPropertyAssignment(ts.createIdentifier('type'), ts.createLiteral('registry'))
            ]);
            const decl = ts.createVariableDeclaration(fakeComponentName, undefined, obj);
            const stmt = ts.createVariableStatement(undefined, [decl]);
            let index = 0;
            for (let i = 0; i < statements.length; i++) {
                if (!ts.isImportDeclaration(statements[i])) {
                    index = i;
                    break;
                }
            }
            statements.splice(index, 0, stmt);
        }
        return ts.updateSourceFileNode(node, [...statements]);
    }
    setLazyImport(node) {
        const importPath = node.moduleSpecifier.text;
        const importClause = node.importClause;
        if (importClause && importClause.name && importClause.name.text) {
            this.modulesMap.set(importClause.name.text, importPath);
        }
    }
    setOutletName(node) {
        if (node.importClause) {
            const importClause = node.importClause;
            if (importClause && importClause.name && importClause.name.text) {
                this.outletName = importClause.name.text;
            }
            else if (importClause.namedBindings) {
                const namedBindings = importClause.namedBindings;
                namedBindings.elements.some((element) => {
                    const text = element.name.getText();
                    if (text === outletName ||
                        (element.propertyName && element.propertyName.escapedText === outletName)) {
                        this.outletName = text;
                        return true;
                    }
                    return false;
                });
            }
        }
    }
    setWPragma(node) {
        if (node.importClause) {
            const namedBindings = node.importClause.namedBindings;
            namedBindings.elements.some((element) => {
                const text = element.name.getText();
                if (text === wPragma || (element.propertyName && element.propertyName.escapedText === wPragma)) {
                    this.wPragma = text;
                    return true;
                }
                return false;
            });
        }
    }
    replaceTSXElementWithLoadable(inputNode) {
        let node;
        if (ts.isJsxElement(inputNode)) {
            node = inputNode.openingElement;
        }
        else {
            node = inputNode;
        }
        const text = node.tagName.getText();
        const importPath = this.modulesMap.get(text);
        this.ctorCountMap.set(text, (this.ctorCountMap.get(text) || 0) + 1);
        if (importPath) {
            const targetPath = path.posix
                .resolve(this.contextPath, importPath)
                .replace(`${this.basePath}${path.posix.sep}`, '');
            this.log(text, targetPath);
            const outletName = this.outletName ? this.getOutletName(node) : undefined;
            if (this.all ||
                this.bundlePaths.indexOf(targetPath) !== -1 ||
                (outletName && this.outlets.indexOf(outletName) !== -1)) {
                this.registryItems[text] = this.modulesMap.get(text);
                const registryItem = ts.createPropertyAccess(ts.createIdentifier('__autoRegistryItems'), ts.createIdentifier(text));
                const registryExpr = ts.createObjectLiteral([
                    ts.createPropertyAssignment(ts.createIdentifier('label'), ts.createLiteral(`__autoRegistryItem_${text}`)),
                    ts.createPropertyAssignment(ts.createIdentifier('registryItem'), registryItem)
                ]);
                const registryAttribute = ts.createJsxAttribute(ts.createIdentifier('__autoRegistryItem'), ts.createJsxExpression(undefined, registryExpr));
                this.setSharedModules(`__autoRegistryItem_${text}`, {
                    path: this.registryItems[text],
                    outletName
                });
                const attrs = ts.updateJsxAttributes(node.attributes, [
                    ...node.attributes.properties,
                    registryAttribute
                ]);
                this.needsLoadable = true;
                this.ctorCountMap.set(text, (this.ctorCountMap.get(text) || 0) - 1);
                if (ts.isJsxElement(inputNode)) {
                    let openingElement;
                    if (ts.updateJsxOpeningElement.length === 3) {
                        openingElement = ts.updateJsxOpeningElement(node, ts.createIdentifier(fakeComponentName), attrs);
                    }
                    else {
                        openingElement = ts.updateJsxOpeningElement(node, ts.createIdentifier(fakeComponentName), node.typeArguments, attrs);
                    }
                    const closingElement = ts.updateJsxClosingElement(inputNode.closingElement, ts.createIdentifier(fakeComponentName));
                    return ts.updateJsxElement(inputNode, openingElement, inputNode.children, closingElement);
                }
                else {
                    if (ts.updateJsxSelfClosingElement.length === 3) {
                        return ts.updateJsxSelfClosingElement(inputNode, ts.createIdentifier(fakeComponentName), attrs);
                    }
                    else {
                        return ts.updateJsxSelfClosingElement(inputNode, ts.createIdentifier(fakeComponentName), inputNode.typeArguments, attrs);
                    }
                }
            }
        }
        return inputNode;
    }
    setSharedModules(registryItemName, meta) {
        const targetPath = path.posix
            .resolve(this.contextPath, meta.path)
            .replace(`${this.basePath}${path.posix.sep}`, '');
        shared.modules = shared.modules || {};
        shared.modules[registryItemName] = shared.modules[registryItemName] || { path: targetPath, outletName: [] };
        if (meta.outletName) {
            shared.modules[registryItemName].outletName.push(meta.outletName);
        }
    }
    log(name, path) {
        shared.all = shared.all || {};
        shared.all[name] = path;
    }
    replaceWidgetClassWithString(node) {
        const text = node.arguments[0].getText();
        const importPath = this.modulesMap.get(text);
        const targetPath = path.posix
            .resolve(this.contextPath, importPath)
            .replace(`${this.basePath}${path.posix.sep}`, '');
        const outletName = this.outletName ? this.getOutletName(node) : undefined;
        this.ctorCountMap.set(text, (this.ctorCountMap.get(text) || 0) + 1);
        this.log(text, targetPath);
        if (this.all ||
            this.bundlePaths.indexOf(targetPath) !== -1 ||
            (outletName && this.outlets.indexOf(outletName) !== -1)) {
            this.ctorCountMap.set(text, (this.ctorCountMap.get(text) || 0) - 1);
            this.registryItems[text] = this.modulesMap.get(text);
            const registryItem = ts.createPropertyAccess(ts.createIdentifier('__autoRegistryItems'), ts.createIdentifier(text));
            const registryExpr = ts.createObjectLiteral([
                ts.createPropertyAssignment(ts.createIdentifier('label'), ts.createLiteral(`__autoRegistryItem_${text}`)),
                ts.createPropertyAssignment(ts.createIdentifier('registryItem'), registryItem)
            ]);
            this.setSharedModules(`__autoRegistryItem_${text}`, { path: this.registryItems[text], outletName });
            return ts.updateCall(node, node.expression, node.typeArguments, [registryExpr, ...node.arguments.slice(1)]);
        }
        return node;
    }
    removeImportStatements(nodes) {
        const importsToRemove = [];
        Object.keys(this.registryItems).forEach((label) => {
            if (this.ctorCountMap.get(label) === 0) {
                importsToRemove.push(this.registryItems[label]);
            }
        });
        return nodes.filter((node) => {
            if (ts.isImportDeclaration(node) &&
                importsToRemove.indexOf(node.moduleSpecifier.text) !== -1) {
                return false;
            }
            return true;
        });
    }
    isWCall(node) {
        return !!(this.wPragma &&
            this.modulesMap.size &&
            ts.isCallExpression(node) &&
            node.expression.getText() === this.wPragma &&
            node.arguments &&
            node.arguments.length);
    }
    getOutletName(node) {
        let parent = node.parent;
        while (parent) {
            if ((ts.isMethodDeclaration(parent) || ts.isPropertyAssignment(parent)) &&
                parent.name.getText() === outletRendererName) {
                const w = parent.parent.parent;
                if (ts.isCallExpression(w) &&
                    w.expression.getText() === this.wPragma &&
                    ts.isIdentifier(w.arguments[0]) &&
                    w.arguments[0].getText() === this.outletName &&
                    ts.isObjectLiteralExpression(w.arguments[1])) {
                    const objectLiteral = w.arguments[1];
                    for (let i = 0; i < objectLiteral.properties.length; i++) {
                        const property = objectLiteral.properties[i];
                        if (ts.isPropertyAssignment(property) &&
                            property.name.getText() === outletIdName &&
                            ts.isStringLiteral(property.initializer)) {
                            return property.initializer.text;
                        }
                    }
                }
            }
            else if (ts.isJsxAttribute(parent) && parent.name.getText() === outletRendererName) {
                const tsx = parent.parent.parent;
                if (ts.isJsxOpeningLikeElement(tsx) && tsx.tagName.getText() === this.outletName) {
                    const properties = tsx.attributes.properties;
                    for (let i = 0; i < properties.length; i++) {
                        const attribute = properties[i];
                        if (attribute.name.getText() === outletIdName &&
                            attribute.initializer &&
                            ts.isStringLiteral(attribute.initializer)) {
                            return attribute.initializer.text;
                        }
                    }
                }
            }
            parent = parent.parent;
        }
        return undefined;
    }
}
const registryTransformer = function (context) {
    const basePath = this.basePath;
    const bundlePaths = this.bundlePaths;
    const all = this.all;
    const outlets = this.outlets;
    const opts = context.getCompilerOptions();
    const sync = this.sync;
    const { module } = opts;
    const legacyModule = module === ts.ModuleKind.CommonJS || module === ts.ModuleKind.AMD || module === ts.ModuleKind.UMD;
    return function (node) {
        const root = node;
        const contextPath = path.dirname(path.relative(basePath, node.getSourceFile().fileName));
        const visitor = new Visitor({
            context,
            contextPath,
            bundlePaths,
            basePath,
            legacyModule,
            root,
            all,
            outlets,
            sync
        });
        let result = ts.visitNode(node, visitor.visit.bind(visitor));
        return visitor.end(result);
    };
};
exports.default = (basePath, bundlePaths, all = false, outlets = [], sync = false) => registryTransformer.bind({ bundlePaths, basePath, all, outlets, sync });
//# sourceMappingURL=index.js.map