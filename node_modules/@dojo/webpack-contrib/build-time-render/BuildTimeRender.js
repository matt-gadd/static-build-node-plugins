"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const helpers_1 = require("./helpers");
const filterCss = require('filter-css');
const puppeteer = require('puppeteer');
var SourceNode = require("source-map").SourceNode;
var SourceMapConsumer = require("source-map").SourceMapConsumer;
class BuildTimeRender {
    constructor(args) {
        this._cssFiles = [];
        this._inlinedCssClassNames = [];
        this._useHistory = false;
        const { paths = [], root = '', useManifest = false, entries, useHistory, puppeteerOptions } = args;
        const path = paths[0];
        const initialPath = typeof path === 'object' ? path.path : path;
        this._puppeteerOptions = puppeteerOptions;
        this._paths = paths;
        this._root = root;
        this._useManifest = useManifest;
        this._entries = entries.map((entry) => `${entry.replace('.js', '')}.js`);
        this._manifest = this._entries.reduce((manifest, entry) => {
            manifest[entry] = entry;
            return manifest;
        }, {});
        this._useHistory = useHistory !== undefined ? useHistory : paths.length > 0 && !/^#.*/.test(initialPath);
    }
    _writeIndexHtml({ html, script, path = '', styles }) {
        path = typeof path === 'object' ? path.path : path;
        const prefix = helpers_1.getPrefix(path);
        if (this._head) {
            const head = this._head.replace(/href="(?!(http(s)?|\/))(.*?)"/g, `href="${prefix}$3"`);
            html = html.replace(/<head>([\s\S]*?)<\/head>/gm, head);
        }
        const css = this._cssFiles.reduce((css, entry) => {
            html = html.replace(`<link href="${prefix}${entry}" rel="stylesheet">`, `<style>${styles}</style>`);
            css = `${css}<link rel="stylesheet" href="${prefix}${entry}" media="none" onload="if(media!='all')media='all'" />`;
            return css;
        }, '');
        html = html.replace(/^(\s*)(\r\n?|\n)/gm, '').trim();
        html = html.replace(this._createScripts(path), `${script}${css}${this._createScripts(path)}`);
        fs_extra_1.outputFileSync(path_1.join(this._output, ...path.split('/'), 'index.html'), html);
    }
    _createScripts(path = '') {
        const prefix = this._useHistory ? helpers_1.getPrefix(path) : '';
        return this._entries.reduce((script, entry) => `${script}<script type="text/javascript" src="${prefix}${this._manifest[entry]}"></script>`, '');
    }
    _filterCss(classes) {
        return this._cssFiles.reduce((result, entry) => {
            let filteredCss = filterCss(path_1.join(this._output, entry), (context, value) => {
                if (context === 'selector') {
                    value = value.replace(/(:| ).*/, '');
                    value = value
                        .split('.')
                        .slice(0, 2)
                        .join('.');
                    const firstChar = value.substr(0, 1);
                    if (!this._useHistory && this._inlinedCssClassNames.indexOf(value) !== -1) {
                        return true;
                    }
                    if (classes.indexOf(value) !== -1 || ['.', '#'].indexOf(firstChar) === -1) {
                        this._inlinedCssClassNames.push(value);
                        return false;
                    }
                    return true;
                }
            });
            filteredCss = filteredCss
                .replace(/\/\*.*\*\//g, '')
                .replace(/^(\s*)(\r\n?|\n)/gm, '')
                .trim();
            result = `${result}${filteredCss}`;
            return result;
        }, '');
    }
    _getRenderResult(page, path = undefined, allContents = true) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const classes = yield helpers_1.getClasses(page);
            let pathValue = typeof path === 'object' ? path.path : path;
            let html = allContents ? yield page.content() : yield helpers_1.getForSelector(page, `#${this._root}`);
            let styles = this._filterCss(classes);
            let script = '';
            html = html.replace(/http:\/\/localhost:\d+\//g, '');
            if (this._useHistory) {
                styles = styles.replace(/url\("(?!(http(s)?|\/))(.*?)"/g, `url("${helpers_1.getPrefix(pathValue)}$3"`);
                html = html.replace(/src="(?!(http(s)?|\/))(.*?)"/g, `src="${helpers_1.getPrefix(pathValue)}$3"`);
                script = helpers_1.generateBasePath(pathValue);
            }
            return { html, styles, script, path };
        });
    }
    apply(compiler) {
        if (!this._root) {
            return;
        }
        compiler.hooks.afterEmit.tapAsync(this.constructor.name, (compilation, callback) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._output = compiler.options.output && compiler.options.output.path;
            if (!this._output) {
                return Promise.resolve().then(() => {
                    callback();
                });
            }
            if (this._useManifest) {
                this._manifest = JSON.parse(fs_extra_1.readFileSync(path_1.join(this._output, 'manifest.json'), 'utf-8'));
            }
            let originalIndexHtml = fs_extra_1.readFileSync(path_1.join(this._output, 'index.html'), 'utf-8');
            const matchingHead = /<head>([\s\S]*?)<\/head>/.exec(originalIndexHtml);
            if (matchingHead) {
                this._head = matchingHead[0];
            }
            this._cssFiles = this._entries.reduce((files, entry) => {
                const fileName = this._manifest[entry.replace('.js', '.css')] || entry.replace('.js', '.css');
                const exists = fs_extra_1.existsSync(path_1.join(this._output, fileName));
                if (exists) {
                    files.push(fileName);
                }
                return files;
            }, []);
            const browser = yield puppeteer.launch();
            const app = yield helpers_1.serve(`${this._output}`);
            try {
                const page = yield browser.newPage();
				/*yield page.on('console', msg => console.warn('PAGE LOG:', msg.text()));*/
                yield helpers_1.setHasFlags(page);
				yield page.exposeFunction('__communicator', async (modulePath, args) => {
					const res = require(`${process.cwd()}/${modulePath}`).default(...args);
					const manifest = JSON.parse(fs_extra_1.readFileSync(path_1.join(this._output, 'manifest.json'), 'utf-8'));
					let ex = ''
					let file;
					let sourceMap;
					Object.keys(manifest).forEach((filename) => {
						if (/\.js$/.test(filename)) {
							const contents = fs_extra_1.readFileSync(path_1.join(this._output, manifest[filename]), 'utf-8');
							if (contents.indexOf(`/** @preserve build-cache '${modulePath}' **/`) !== -1) {
								ex = contents;
								file = manifest[filename];
								sourceMap = fs_extra_1.readFileSync(path_1.join(this._output, file + '.map'), 'utf-8');
							}
						}
					});

					var node = SourceNode.fromStringWithSourceMap(ex, new SourceMapConsumer(sourceMap));
					node.prepend(`window.__cache=window.__cache||{};window.__cache['${modulePath}']=window.__cache['${modulePath}']||{};window.__cache['${modulePath}']['${JSON.stringify(args)}'] = { value: ${JSON.stringify(res)} };\n`)
					var result = node.toStringWithSourceMap({ file });
					fs_extra_1.writeFileSync(path_1.join(this._output, file), result.code, 'utf-8');
					fs_extra_1.writeFileSync(path_1.join(this._output, file + '.map'), JSON.stringify(result.map), 'utf-8');
					return res;
				});
                const wait = page.waitForNavigation({ waitUntil: 'networkidle0' });
                yield page.goto(`http://localhost:${app.port}/`);
                yield wait;
                if (this._paths.length === 0) {
                    const result = yield this._getRenderResult(page, undefined);
                    this._writeIndexHtml(result);
                }
                else {
                    let renderResults = [];
                    renderResults.push(yield this._getRenderResult(page, undefined, this._useHistory));
                    for (let i = 0; i < this._paths.length; i++) {
                        let path = typeof this._paths[i] === 'object' ? this._paths[i].path : this._paths[i];
                        yield helpers_1.navigate(page, this._useHistory, path);
                        let result = yield this._getRenderResult(page, this._paths[i], this._useHistory);
                        renderResults.push(result);
                    }
                    if (this._useHistory) {
                        renderResults.forEach((result) => {
                            this._writeIndexHtml(result);
                        });
                    }
                    else {
                        const combined = renderResults.reduce((combined, result) => {
                            combined.styles = result.styles
                                ? `${combined.styles}\n${result.styles}`
                                : combined.styles;
                            combined.html.push(result.html);
                            combined.paths.push(result.path || '');
                            return combined;
                        }, { styles: '', html: [], paths: [] });
                        let html = fs_extra_1.readFileSync(path_1.join(this._output, 'index.html'), 'utf-8');
                        const script = helpers_1.generateRouteInjectionScript(combined.html, combined.paths, this._root);
                        this._writeIndexHtml({ styles: combined.styles, html, script });
                    }
                }
            }
            catch (error) {
                throw error;
            }
            finally {
				yield browser.close();
				yield app.server.close();
				callback();
            }
        }));
    }
}
exports.default = BuildTimeRender;
//# sourceMappingURL=BuildTimeRender.js.map
