"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CopyWebpackPlugin = require('copy-webpack-plugin');
const { GenerateSW } = require('workbox-webpack-plugin');
const precachePropertiesMap = {
    baseDir: 'globDirectory',
    ignore: 'globIgnores',
    include: 'globPatterns',
    index: 'directoryIndex',
    maxCacheSize: 'maximumFileSizeToCacheInBytes',
    strict: 'globStrict',
    symlinks: 'globFollow'
};
/**
 * A custom webpack plugin that either generates a service worker with predefined routes, or copies the specified
 * service worker file to the output directory.
 *
 * @param compiler The webpack compiler instance
 */
class ServiceWorkerPlugin {
    constructor(serviceWorker) {
        this._serviceWorker = serviceWorker;
    }
    /**
     * Generate the service worker or copy the custom service worker to the output directory.
     *
     * @param compiler The webpack compiler instance
     */
    apply(compiler) {
        if (typeof this._serviceWorker === 'string') {
            return this._copyServiceWorker(compiler);
        }
        const { bundles, cachePrefix, clientsClaim, excludeBundles, importScripts = [], precache = {}, routes = [], skipWaiting } = this._serviceWorker;
        const precacheProperties = Object.keys(precache).reduce((precacheProperties, key) => {
            const workboxKey = precachePropertiesMap[key];
            if (workboxKey) {
                precacheProperties[workboxKey] = precache[key];
            }
            return precacheProperties;
        }, Object.create(null));
        const generateSW = new GenerateSW(this._getDefinedOptions(Object.assign({}, precacheProperties, { cacheId: cachePrefix, chunks: bundles, clientsClaim, excludeChunks: excludeBundles, importScripts, importWorkboxFrom: 'local', skipWaiting, runtimeCaching: routes.map((route) => {
                const { options = {}, strategy, urlPattern } = route;
                const { cacheName, cacheableResponse, expiration, networkTimeoutSeconds } = options;
                if (!urlPattern || !strategy) {
                    throw new Error('Each route must have both a `urlPattern` and `strategy`');
                }
                return {
                    urlPattern: new RegExp(urlPattern),
                    handler: strategy,
                    options: this._getDefinedOptions({
                        cacheName,
                        cacheableResponse,
                        expiration,
                        networkTimeoutSeconds
                    })
                };
            }) })));
        generateSW.apply(compiler);
    }
    /**
     * @private
     * Return a webpack plugin that copies the specified service worker file to the output directory.
     *
     * @param compiler The webpack compiler instance
     */
    _copyServiceWorker(compiler) {
        if (!this._serviceWorker) {
            throw new Error('The service worker path must be a non-empty string');
        }
        compiler.hooks.beforeRun.tapAsync(this.constructor.name, (compiler, next) => {
            new CopyWebpackPlugin({ from: this._serviceWorker }).apply(compiler);
            next();
        });
    }
    /**
     * @private
     * Return an object containing only defined values.
     *
     * @param options The options to filter
     */
    _getDefinedOptions(options) {
        return Object.keys(options).reduce((filtered, key) => {
            const value = options[key];
            if (typeof value !== 'undefined') {
                filtered[key] = value;
            }
            return filtered;
        }, Object.create(null));
    }
}
exports.default = ServiceWorkerPlugin;
//# sourceMappingURL=ServiceWorkerPlugin.js.map