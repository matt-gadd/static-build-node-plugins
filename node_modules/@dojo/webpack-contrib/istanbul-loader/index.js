"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const istanbul_lib_instrument_1 = require("istanbul-lib-instrument");
const loader_utils_1 = require("loader-utils");
const source_map_1 = require("source-map");
/**
 * Instrument a source file with istanbul for code coverage.
 *
 * Instrumenter options will be read from the project 'intern.json' file.
 *
 * @param content the source code
 * @param sourceMap an optional source map
 */
exports.default = function (source, sourceMap) {
    const callback = this.async();
    const options = (Object.assign({}, loader_utils_1.getOptions(this)) || {});
    const _sourceMap = sourceMap;
    const instrumenterOptions = Object.assign({ produceSourceMap: true }, (options.instrumenterOptions || {}));
    if (options.coverageVariable) {
        instrumenterOptions.coverageVariable = options.coverageVariable;
    }
    const instrumenter = istanbul_lib_instrument_1.createInstrumenter(instrumenterOptions);
    // For the code coverage to work we need to modify the sources in the
    // source map to point back to the original file. The files coming in have
    // been generated by webpack and look like,
    // "node_modules/tslint-loader?!path/to/file/css-modules!path/to/file.ts.
    // We need these files to simply be "path/to/file.ts".
    if (_sourceMap) {
        _sourceMap.sources = (_sourceMap.sources || []).map((source) => {
            const lastBang = source.lastIndexOf('!');
            if (lastBang !== -1) {
                return source.substr(lastBang + 1);
            }
            return source;
        });
    }
    instrumenter.instrument(String(source), this.resourcePath, (error, instrumentedSource) => {
        if (error) {
            callback(error);
        }
        else {
            try {
                const instrumentedSourceMap = instrumenter.lastSourceMap();
                let updatedSourceMap;
                if (_sourceMap) {
                    updatedSourceMap = mergeSourceMaps(instrumentedSourceMap, _sourceMap);
                }
                else {
                    updatedSourceMap = instrumentedSourceMap;
                }
                callback(null, instrumentedSource, updatedSourceMap);
            }
            catch (err) {
                callback(err);
            }
        }
    }, _sourceMap);
};
/**
 * Merge a list of source maps generated through successive transforms of a
 * single file.
 *
 * Maps should be in reverse order (i.e., the first map should be
 * from the most recent transform).
 *
 * @param maps an array of raw source maps in order from the most recently
 * generated map to the original map
 * @returns a source map that maps locations in the final transformed file to
 * the original file
 */
function mergeSourceMaps(...maps) {
    const consumers = maps.map((map) => new source_map_1.SourceMapConsumer(map));
    const generator = new source_map_1.SourceMapGenerator({ file: maps[0].file });
    // Walk through each mapping of the most recent source map
    consumers[0].eachMapping((mapping) => {
        const original = getOriginalPosition(consumers, mapping);
        if (original.line !== null) {
            generator.addMapping({
                generated: {
                    line: mapping.generatedLine,
                    column: mapping.generatedColumn
                },
                original: {
                    line: original.line,
                    column: original.column
                },
                source: mapping.source,
                name: mapping.name
            });
        }
    });
    return JSON.parse(generator.toString());
}
/**
 * Find the original position for a given position.
 *
 * @param consumers a list of source map consumers, from the most recently
 * generated to the original
 * @param mapping a mapping item from the most recent source map
 * @returns a position in the original file
 */
function getOriginalPosition(consumers, mapping) {
    return consumers.reduce((original, consumer) => {
        // Ignore missing mappings
        if (isMappedPosition(original)) {
            return consumer.originalPositionFor(original);
        }
        return original;
    }, {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
    });
}
/**
 * Indicate whether the given value is a MappedPosition
 */
function isMappedPosition(position) {
    return position.line != null && position.column != null && position.source != null;
}
//# sourceMappingURL=index.js.map