"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_config_1 = require("./base.config");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const fs = require("fs");
const path = require("path");
const BuildTimeRender_1 = require("@dojo/webpack-contrib/build-time-render/BuildTimeRender");
const ServiceWorkerPlugin_1 = require("@dojo/webpack-contrib/service-worker-plugin/ServiceWorkerPlugin");
const CleanWebpackPlugin = require("clean-webpack-plugin");
const CopyWebpackPlugin = require("copy-webpack-plugin");
const ManifestPlugin = require("webpack-manifest-plugin");
const WebpackPwaManifest = require('webpack-pwa-manifest');
function webpackConfig(args) {
    const config = base_config_1.default(args);
    const manifest = args.pwa && args.pwa.manifest;
    const serviceWorker = args.pwa && args.pwa.serviceWorker;
    const { plugins, output, module } = config;
    const outputPath = path.join(output.path, 'dev');
    const assetsDir = path.join(process.cwd(), 'assets');
    const assetsDirExists = fs.existsSync(assetsDir);
    if (!args.singleBundle) {
        config.optimization = Object.assign({}, config.optimization, { runtimeChunk: { name: 'runtime' } });
    }
    config.plugins = [
        ...plugins,
        assetsDirExists && new CopyWebpackPlugin([{ from: assetsDir, to: path.join(outputPath, 'assets') }]),
        new ManifestPlugin(),
        new HtmlWebpackPlugin({
            inject: true,
            chunks: args.singleBundle ? ['main'] : ['runtime', 'main'],
            meta: manifest ? { 'mobile-web-app-capable': 'yes' } : {},
            template: 'src/index.html'
        }),
        manifest &&
            new WebpackPwaManifest(Object.assign({}, manifest, { ios: true, icons: Array.isArray(manifest.icons)
                    ? manifest.icons.map((icon) => (Object.assign({}, icon, { ios: true })))
                    : manifest.icons })),
        new CleanWebpackPlugin(['dev'], { root: output.path, verbose: false })
    ].filter((item) => item);
    if (module) {
        module.rules = module.rules.map((rule) => {
            if (Array.isArray(rule.use)) {
                rule.use = rule.use.map((loader) => {
                    if (typeof loader === 'string') {
                        return loader;
                    }
                    const { loader: loaderName, options } = loader;
                    if (loaderName === '@dojo/webpack-contrib/static-build-loader') {
                        if (typeof options === 'object') {
                            options.features = Object.assign({}, (options.features || {}), { 'dojo-debug': true });
                        }
                        return {
                            loader: loaderName,
                            options
                        };
                    }
                    return loader;
                });
            }
            return rule;
        });
    }
    if (serviceWorker) {
        const serviceWorkerOptions = typeof serviceWorker === 'string' ? serviceWorker : Object.assign({ cachePrefix: base_config_1.packageName }, serviceWorker);
        config.plugins.push(new ServiceWorkerPlugin_1.default(serviceWorkerOptions));
        if (typeof serviceWorker !== 'string') {
            const entry = config.entry;
            entry[base_config_1.mainEntry].push('@dojo/webpack-contrib/service-worker-plugin/service-worker-entry');
        }
    }
    if (args.watch !== 'memory' && args['build-time-render']) {
        config.plugins.push(new BuildTimeRender_1.default(Object.assign({}, args['build-time-render'], { entries: args.singleBundle ? Object.keys(config.entry) : ['runtime', ...Object.keys(config.entry)], useManifest: true })));
    }
    config.output = Object.assign({}, output, { path: outputPath });
    return config;
}
exports.default = webpackConfig;
//# sourceMappingURL=dev.config.js.map
