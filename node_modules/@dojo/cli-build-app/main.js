"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const express = require("express");
const logUpdate = require("log-update");
const ora = require("ora");
const path = require("path");
const url = require("url");
const webpack = require("webpack");
const chalk_1 = require("chalk");
const fs = require("fs");
const https = require("https");
const proxy = require("http-proxy-middleware");
const history = require("connect-history-api-fallback");
const pkgDir = require('pkg-dir');
const expressStaticGzip = require('express-static-gzip');
const dev_config_1 = require("./dev.config");
const unit_config_1 = require("./unit.config");
const functional_config_1 = require("./functional.config");
const dist_config_1 = require("./dist.config");
const logger_1 = require("./logger");
const eject_1 = require("./util/eject");
const fixMultipleWatchTrigger = require('webpack-mild-compile');
const hotMiddleware = require('webpack-hot-middleware');
const webpackMiddleware = require('webpack-dev-middleware');
const testModes = ['test', 'unit', 'functional'];
function createCompiler(config) {
    const compiler = webpack(config);
    fixMultipleWatchTrigger(compiler);
    return compiler;
}
function createWatchCompiler(config) {
    const compiler = createCompiler(config);
    const spinner = ora('building').start();
    compiler.hooks.invalid.tap('@dojo/cli-build-app', () => {
        logUpdate('');
        spinner.start();
    });
    compiler.hooks.done.tap('@dojo/cli-build-app', () => {
        spinner.stop();
    });
    return compiler;
}
function build(config, args) {
    const compiler = createCompiler(config);
    const spinner = ora('building').start();
    return new Promise((resolve, reject) => {
        compiler.run((err, stats) => {
            spinner.stop();
            if (err) {
                reject(err);
            }
            if (stats) {
                const runningMessage = args.serve ? `Listening on port ${args.port}...` : '';
                const hasErrors = logger_1.default(stats.toJson({ warningsFilter }), config, runningMessage);
                if (hasErrors) {
                    reject({});
                    return;
                }
            }
            if (args.mode === 'test') {
                console.warn('Using `--mode=test` is deprecated and has only built the unit test bundle. This mode will be removed in the next major release, please use `unit` or `functional` explicitly instead.');
            }
            resolve(args.serve);
        });
    });
}
function buildNpmDependencies() {
    try {
        const packagePath = pkgDir.sync(__dirname);
        const packageJsonFilePath = path.join(packagePath, 'package.json');
        const packageJson = require(packageJsonFilePath);
        return Object.assign({ [packageJson.name]: packageJson.version }, packageJson.dependencies);
    }
    catch (e) {
        throw new Error(`Failed reading dependencies from package.json - ${e.message}`);
    }
}
function fileWatch(config, args) {
    const compiler = createWatchCompiler(config);
    return new Promise((resolve, reject) => {
        const watchOptions = config.watchOptions;
        compiler.watch(watchOptions, (err, stats) => {
            if (err) {
                reject(err);
            }
            if (stats) {
                const runningMessage = args.serve ? `Listening on port ${args.port}` : 'watching...';
                logger_1.default(stats.toJson({ warningsFilter }), config, runningMessage);
            }
            resolve();
        });
    });
}
function memoryWatch(config, args, app) {
    const entry = config.entry;
    const plugins = config.plugins;
    const timeout = 20 * 1000;
    plugins.push(new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin());
    Object.keys(entry).forEach((name) => {
        entry[name].unshift(`webpack-hot-middleware/client?timeout=${timeout}&reload=true`);
        entry[name].unshift('eventsource-polyfill');
    });
    const watchOptions = config.watchOptions;
    const compiler = createWatchCompiler(config);
    compiler.hooks.done.tap('@dojo/cli-build-app', (stats) => {
        logger_1.default(stats.toJson({ warningsFilter }), config, `Listening on port ${args.port}...`);
    });
    app.use(webpackMiddleware(compiler, {
        logLevel: 'silent',
        noInfo: true,
        publicPath: '/',
        watchOptions
    }), hotMiddleware(compiler, {
        heartbeat: timeout / 2
    }));
    return Promise.resolve();
}
function serve(config, args) {
    let isHttps = false;
    const app = express();
    app.use(history({
        rewrites: [
            {
                from: /^.*\.(?!html).*$/,
                to: (context) => {
                    const { host, referer } = context.request.headers;
                    const { url: originalUrl } = context.request;
                    if (!referer || referer.endsWith(host + originalUrl)) {
                        return originalUrl;
                    }
                    const parsedUrl = url.parse(referer);
                    const pathnames = parsedUrl && parsedUrl.pathname ? parsedUrl.pathname.split('/') : [];
                    const urlRewrite = pathnames.reduce((rewrite, segment) => {
                        if (!segment) {
                            return rewrite;
                        }
                        return rewrite.replace(`/${segment}`, '');
                    }, context.parsedUrl.pathname);
                    return urlRewrite;
                }
            }
        ]
    }));
    if (args.watch !== 'memory') {
        const outputDir = (config.output && config.output.path) || process.cwd();
        if (args.mode === 'dist' && Array.isArray(args.compression)) {
            const useBrotli = args.compression.includes('brotli');
            app.use(expressStaticGzip(outputDir, {
                enableBrotli: useBrotli,
                orderPreference: useBrotli ? ['br'] : undefined
            }));
        }
        else {
            app.use(express.static(outputDir));
        }
    }
    if (args.proxy) {
        Object.keys(args.proxy).forEach((context) => {
            const options = args.proxy[context];
            if (typeof options === 'string') {
                app.use(proxy(context, { target: options }));
            }
            else {
                app.use(proxy(context, options));
            }
        });
    }
    const defaultKey = path.resolve('.cert', 'server.key');
    const defaultCrt = path.resolve('.cert', 'server.crt');
    if (fs.existsSync(defaultKey) && fs.existsSync(defaultCrt)) {
        isHttps = true;
    }
    return Promise.resolve()
        .then(() => {
        if (args.watch === 'memory' && args.mode === 'dev') {
            return memoryWatch(config, args, app);
        }
        if (args.watch) {
            if (args.watch === 'memory') {
                console.warn('Memory watch requires `--mode=dev`. Using file watch instead...');
            }
            return fileWatch(config, args);
        }
        return build(config, args);
    })
        .then(() => {
        return new Promise((resolve, reject) => {
            if (isHttps) {
                https
                    .createServer({
                    key: fs.readFileSync(defaultKey),
                    cert: fs.readFileSync(defaultCrt)
                }, app)
                    .listen(args.port, (error) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve();
                    }
                });
            }
            else {
                app.listen(args.port, (error) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve();
                    }
                });
            }
        });
    });
}
function warningsFilter(warning) {
    return warning.includes('[mini-css-extract-plugin]\nConflicting order between');
}
const command = {
    group: 'build',
    name: 'app',
    description: 'create a build of your application',
    register(options) {
        options('mode', {
            describe: 'the output mode',
            alias: 'm',
            default: 'dist',
            choices: ['dist', 'dev', 'test', 'unit', 'functional']
        });
        options('watch', {
            describe: 'watch for file changes: "memory" (dev mode only) or "file" (all modes; default)',
            alias: 'w'
        });
        options('serve', {
            describe: 'start a webserver',
            alias: 's',
            type: 'boolean'
        });
        options('port', {
            describe: 'used in conjunction with the serve option to specify the webserver port',
            alias: 'p',
            default: 9999,
            type: 'number'
        });
        options('single-bundle', {
            describe: 'Limits the built output to single bundle',
            default: false,
            type: 'boolean'
        });
        options('legacy', {
            describe: 'build app with legacy browser support',
            alias: 'l',
            default: false,
            type: 'boolean'
        });
        options('feature', {
            describe: 'List of features to include',
            alias: 'f',
            array: true,
            coerce: (args) => {
                return args.reduce((newArgs, arg) => {
                    const parts = arg.split('=');
                    if (parts.length === 1) {
                        newArgs[arg] = true;
                    }
                    else if (parts.length === 2) {
                        newArgs[parts[0]] = parts[1];
                    }
                    return newArgs;
                }, {});
            }
        });
    },
    run(helper, args) {
        console.log = () => { };
        let config;
        let { feature } = args, remainingArgs = tslib_1.__rest(args, ["feature"]);
        remainingArgs = Object.assign({}, remainingArgs, { features: Object.assign({}, remainingArgs.features, feature) });
        if (args.mode === 'dev') {
            config = dev_config_1.default(remainingArgs);
        }
        else if (args.mode === 'unit' || args.mode === 'test') {
            config = unit_config_1.default(remainingArgs);
        }
        else if (args.mode === 'functional') {
            config = functional_config_1.default(remainingArgs);
        }
        else {
            config = dist_config_1.default(remainingArgs);
        }
        if (args.serve) {
            if (testModes.indexOf(args.mode) !== -1) {
                return Promise.reject(new Error(`Cannot use \`--serve\` with \`--mode=${args.mode}\``));
            }
            return serve(config, args);
        }
        if (args.watch) {
            if (args.watch === 'memory') {
                console.warn('Memory watch requires the dev server. Using file watch instead...');
            }
            return fileWatch(config, args);
        }
        return build(config, args);
    },
    eject(helper) {
        return {
            copy: {
                path: __dirname,
                files: [
                    eject_1.moveBuildOptions(`${this.group}-${this.name}`),
                    './base.config.js',
                    './base.test.config.js',
                    './dev.config.js',
                    './dist.config.js',
                    './ejected.config.js',
                    './unit.config.js',
                    './functional.config.js'
                ]
            },
            hints: [
                `to build run ${chalk_1.default.underline('./node_modules/.bin/webpack --config ./config/build-app/ejected.config.js --env.mode={dev|dist|unit|functional}')}`
            ],
            npm: {
                devDependencies: Object.assign({}, buildNpmDependencies())
            }
        };
    }
};
exports.default = command;
//# sourceMappingURL=main.js.map