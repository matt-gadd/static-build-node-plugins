"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BuildTimeRender_1 = require("@dojo/webpack-contrib/build-time-render/BuildTimeRender");
const BundleAnalyzerPlugin_1 = require("@dojo/webpack-contrib/webpack-bundle-analyzer/BundleAnalyzerPlugin");
const ServiceWorkerPlugin_1 = require("@dojo/webpack-contrib/service-worker-plugin/ServiceWorkerPlugin");
const CleanWebpackPlugin = require("clean-webpack-plugin");
const CopyWebpackPlugin = require("copy-webpack-plugin");
const fs = require("fs");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const path = require("path");
const webpack = require("webpack");
const WebpackChunkHash = require("webpack-chunk-hash");
const ManifestPlugin = require("webpack-manifest-plugin");
const base_config_1 = require("./base.config");
const BrotliPlugin = require('brotli-webpack-plugin');
const CompressionPlugin = require('compression-webpack-plugin');
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const WebpackPwaManifest = require('webpack-pwa-manifest');
const banner = `
[Dojo](https://dojo.io/)
Copyright [JS Foundation](https://js.foundation/) & contributors
[New BSD license](https://github.com/dojo/meta/blob/master/LICENSE)
All rights reserved
`;
function webpackConfig(args) {
    const config = base_config_1.default(args);
    const manifest = args.pwa && args.pwa.manifest;
    const serviceWorker = args.pwa && args.pwa.serviceWorker;
    const { plugins, output } = config;
    const outputPath = path.join(output.path, 'dist');
    const assetsDir = path.join(process.cwd(), 'assets');
    const assetsDirExists = fs.existsSync(assetsDir);
    config.mode = 'production';
    config.optimization = Object.assign({}, config.optimization, { minimizer: [
            new TerserPlugin({ sourceMap: true, cache: true }),
            new OptimizeCssAssetsPlugin({
                cssProcessor: require('cssnano'),
                cssProcessorPluginOptions: {
                    preset: ['default', { calc: false }]
                }
            })
        ] });
    if (!args.singleBundle) {
        config.optimization.runtimeChunk = {
            name: 'runtime'
        };
    }
    config.plugins = [
        ...plugins,
        assetsDirExists && new CopyWebpackPlugin([{ from: assetsDir, to: path.join(outputPath, 'assets') }]),
        new ManifestPlugin(),
        new BundleAnalyzerPlugin_1.default({
            analyzerMode: 'static',
            openAnalyzer: false,
            generateStatsFile: true,
            reportFilename: '../info/report.html',
            statsFilename: '../info/stats.json'
        }),
        new HtmlWebpackPlugin({
            inject: true,
            chunks: args.singleBundle ? ['main'] : ['runtime', 'main'],
            meta: manifest ? { 'mobile-web-app-capable': 'yes' } : {},
            template: 'src/index.html'
        }),
        manifest &&
            new WebpackPwaManifest(Object.assign({}, manifest, { ios: true, icons: Array.isArray(manifest.icons)
                    ? manifest.icons.map((icon) => (Object.assign({}, icon, { ios: true })))
                    : manifest.icons })),
        new webpack.BannerPlugin(banner),
        new WebpackChunkHash(),
        new CleanWebpackPlugin(['dist'], { root: output.path, verbose: false })
    ].filter((item) => item);
    if (serviceWorker) {
        const serviceWorkerOptions = typeof serviceWorker === 'string' ? serviceWorker : Object.assign({ cachePrefix: base_config_1.packageName }, serviceWorker);
        config.plugins.push(new ServiceWorkerPlugin_1.default(serviceWorkerOptions));
        if (typeof serviceWorker !== 'string') {
            const entry = config.entry;
            entry[base_config_1.mainEntry].push('@dojo/webpack-contrib/service-worker-plugin/service-worker-entry');
        }
    }
    if (args.watch !== 'memory' && args['build-time-render']) {
        config.plugins.push(new BuildTimeRender_1.default(Object.assign({}, args['build-time-render'], { entries: args.singleBundle ? Object.keys(config.entry) : ['runtime', ...Object.keys(config.entry)], useManifest: true })));
    }
    config.plugins = config.plugins.map((plugin) => {
        if (plugin instanceof MiniCssExtractPlugin) {
            return new MiniCssExtractPlugin({
                filename: '[name].[contenthash].bundle.css'
            });
        }
        return plugin;
    });
    if (Array.isArray(args.compression)) {
        const compressionPlugins = {
            gzip: CompressionPlugin,
            brotli: BrotliPlugin
        };
        args.compression.forEach((algorithm) => {
            const options = { algorithm, test: /\.(js|css|html|svg)$/ };
            const Plugin = compressionPlugins[algorithm];
            config.plugins.push(new Plugin(options));
        });
    }
    config.output = Object.assign({}, output, { path: outputPath, chunkFilename: '[name].[chunkhash].bundle.js', filename: '[name].[chunkhash].bundle.js' });
    return config;
}
exports.default = webpackConfig;
//# sourceMappingURL=dist.config.js.map